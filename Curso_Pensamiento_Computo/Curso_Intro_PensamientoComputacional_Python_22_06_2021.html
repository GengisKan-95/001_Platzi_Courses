<!DOCTYPE HML>
<html lang=es>
    <head>
		<title>Curso Intro pensamiento Computacional Python</title>
    </head>
    <body>
	<header>
	    <h1>Curso de pensmiento computacional con David Aroesti</h1>
	</header>
	<nav><ul>
	    boton01 boton02 boton03 boton04
	</ul></nav>
	<aside></aside>
	<div>
	    <section>
		<!--Titulo de la seccion Intro al pensamiento computacional-->
			<article>
				<header>	
					<h2>Introduccion al pensamiento computacional</h2>	
				</header>
				<p>
				<ul>
					Aprender a resolver problemas de manera computacional
					Entender los puntos en comun entre todos los lenguajes de programacion
					Desarrollar las bases para una carrera en Computer Science
				</ul>
				</p>
				<footer>
				</footer>
			</article>
	    </section>
	    <section>
			<article>
				<header>	
					<h2>Introduccion al computo</h2>
				</header>
				<p>
				<ul>
					“Primera computadora” creada por los griegos, calcula la posición del sol, luna y algunas constelaciones.</br>
					En 1801, Telar de Jacquar, separa el resultado de la informacion que contiene las instrucciones.
					Siglo XIX, Motor analítico de Babbage, haciendo uso del avances en mecánica (engranajes) de su época logra separar instrucciones de calculo y realizar varios cálculos a la vez.
					Finales siglo XIX, ENIAC (Eectronic Numerical Integrator and Computer) usaba sistema decimal. creada por Alan Turing y Alonso. Esta época exigía exactitud en los cálculos que hacían que compañías dependieran de esta(Compañías Ferroviarias por ejemplo). Turing y Alonso, Descubrieron que matemáticamente todos los algoritmos podíamos reducirlos a una secuencia de soluciones matemáticas.
					En 1945, Arquitectura de Von Neumann, EDVAC (Electronic Discrete Variable Automatic Computer) usaba sistema binario. Su aporte fue el descubrimiento que dentro de los componentes electrónicos se puede usar una serie de hadward para realizar el computo y almacenar datos dentro de memoria.
					En 1950, Microchip, ejemplo Apple 1
					En siglo XX, Arquitectura de Feymann, aporta las bases matemáticas de computo cuántico.	
					<iframe width="560" height="315" src="https://www.youtube.com/embed/Vi80-vFav3g" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
				</u>
				</p>
				<footer>
				</footer>
			</article>
	    </section>
	    <section>
			<article>
				<header>
					<h2>Introduccion a los lenguajes de programacion</h2>
				</header>
				<p>
					¿Como dar instrucciones a la computadora? <br>
					Conocimiento delcarativo: Que tipo de relacion existen entre distindos objetos <br>
					Conocimiento imperativo: Como llegar a un resultado <br>
					Definicion de Algoritmo: Lista finita de instrucciones que describen un computo, que cuando se ejecuta con ciertas entradas ejecuta pasos intermedios para llegar a un resultado.<br>A partir de los algoritmos surgieron los lenguajes de programacion para desarrolar diferentes algoritmos.<br><br>Indagar acerca de los lenguajes mas famosos de programacion.<br>
					Todos los lenguajes tienen una sintaxis y semantica.
				</p>
				<footer>
					Fin del tema del video Lenguajes del progrmacion
				</footer>
			</article>
	    </section>
	</div>	
	<div>
	    <section>
			<article>
				<header>	
				<h2>Preparacion de la computadora</h2>
				</header>
				<p>
				Se instala visual Studio Code y Python. Preparando el entorno.
				</p>
				<footer>
				Se termino de instalar todo lo solicitado
				</footer>
			</article>
	    </section>
	    <section>
			<article>
				<header>	
				<h2>Elementos basicos de Python</h2>
				</header>
				<p>
					Bajo nivel: Se parece a los "Unos y ceros" que entienden las computadoras<br>
					Alto nivel: Lenguaje que maneja el ser humano<br>
					Lenguaje de dominio general: Todo lo que se necesita para poder implementar cualquier tipo de algoritmosz<br>
					Lenguaje de dominio especifico: Elaborados para desarrollos puntuales<br>
					Lenguaje interpretado:Mientras corre el programa cada instruccion se traduce a lenguaje maquina <br>
					Lenguaje compilado: Antes de que el codigo sea entregado se convierte a lenguaje maquina<br>
					PYTHON es un lenguaje de alto nivel, General e Interpretado.
				</p>
				<p>
					Elementos basicos:<br>Literales: Formas de inicializar objetos en memoria, ejemplo: el numero 1, la cadena "abc", la palabra True.<br>
					Operadores: Multiplicacion, division, suma, resta, etc.	
				</p>
				<p>
					Objetos,expresiones y tipos numericos<br>Recordar funcion type, investigar.
				</p>
				<footer>
				</footer>
			</article>
	    </section>
	    <section>
			<article>
				<header>	
					<h2>Asignacion de variables</h2>
				</header>
				<p>
					Se deben nombrar las variables de tal forma que pueda ser legible para cualquier programador.<br>
					Investigar que es el "GARBAGE COLLECTOR"<br>
					Investigar sobre las palabras reservadas en Los lenguajes de programacion mas populares <br> Con la funcion id() se puede ver la direccion de la variable en memoria
				</p>
				<footer>
				</footer>
			</article>
	    </section>
	    <section>
			<article>
				<header>	
					<h2>Cadenas y entradas</h2>
				</header>
				<p>
					Aportar con funciones para las cadenas y ver distintos tipos de entradas en el lenguaje de Python
				</p>
				<footer>
				</footer>
			</article>
	    </section>
	    <section>
			<article>
				<header>	
					<h2>Programas Ramificados</h2>
				</header>
				<p>
					Antes de ramificar se deben realizar test. por ejemplo "2==3" para realizar comparaciones.
					<br>Operadores de comparacion<br>Operadores logicos<br>
					<br><br>SE RAMIFICAN LOS PROGRAMAS CON LAS SENTENCIAS IF Y ELSE<br>
				</p>
				<footer>
					El profesor coloca el reto de realizar un programa donde se pida al usuario ingresar el nombre de 2 personas 
					con sus respectivas edades y determinar quien es mayor haciendo uso de if y else.
				</footer>
			</article>
	    </section>
	    <section>
			<article>
				<header>
					<h2>Iteradores</h2>	
				</header>
				<p>
					Investigar acerca de las iteraciones en los diferentes lenguajes de programacion :D<br>
					Ejemplo de iteraciones: While, for.<br>
					El bucle While es un bucle indefinido en el cual se establece la condicion en la que una iteracion terminara.
				</p>
				<footer>
					Participar con ejemplo MELO del while :D
				</footer>
			</article>
	    </section>
	    <section>
			<article>
				<header>	
					<h2>Bucles For</h2>
				</header>
				<p>
					El bucle FOR es un bucle definido donde se preestablece las condiciones de la iteracion por adelantado.
					Un iterable es un objeto que se puede utilizar en un bucle definido.<br>
					Funcion iter la cual retorna un iterator. Es la funcion interna del bucle FOR<br>
					Investigar diferentes usos del continue y break
				</p>
				<footer>
					Realizar varios ejemplos con distintas formas del FOR
				</footer>
			</article>
	    </section>
	</div>	
	<div>
	    <section>
			<article>
				<header>
					<h2>Representacion de flotantes</h2>	
				</header>
				<p>
					Se debe repasar la lectura y leer acerca de la representacion en diferentes sistemas este tipo de numeros. 0.625
				</p>
				<footer>
					Hacer muchos ejercicios con diferentes sistemas... crear un programa que nos ayude a representar numeros flotantes.
				</footer>
			</article>
	    </section>
	    <section>
			<article>
				<header>
					<h2>Enumeracion Exhaustiva</h2>	
				</header>
				<p>
					<ul>
						Tambien se le llama "adivina y verifica"
						Son los primeros algoritmos que hay que tratar.

						En este caso se realiza un ejercicio para obtener la raiz cuadrada aproximada de un numero.
					</ul>
				</p>
				<footer>
					Realizar este programa en los diferentes lenguajes ya aprendidos.
				</footer>
			</article>
	    </section>
	    <section>
			<article>
				<header>
					<h2>Aproximacion de soluciones</h2>
				</header>
				<p>
					Es similar a la enumeracion exhaustiva, pero esta no necesita ser exacta
					Se puede aproximar soluciones con un margen o error llamado Epsilon.
					El ejercicio busca una raiz cuadrada aproximada.
				</p>
				<footer>
					Investigar de donde proviene el concepto de Epsilon
					Importante entender, a mayor precision menor rapidez
					Criterio como ingeniero de software para optimizar tiempo
				</footer>
			</article>
	    </section>
	    <section>
			<article>
				<header>
					<h2>Busqueda Binaria</h2>
				</header>
				<p>
					Es de los mas eficientes
					Para realizar la busqueda binaria, el conjunto debe estar ordenado.
					Altamente eficiente, pues corta el espacio de busqueda en dos por cada iteracion
					El metodo usado en la clase es un metodo numerico llamado Biseccion
				</p>
				<footer>
					Footer de busqueda binaria
				</footer>
			</article>
	    </section>
	</div>	
	<div>
	    <section>
			<article>
				<header>
					<h2>Funciones y abstraccion</h2>	
				</header>
				<p>
					<br>¿Que es la abstraccion?<br>
					<br>No se necesita entender la forma en la cual una herramienta 
					opera internamente para poder hacer uso de ella, operarla<br>
					<br>¿Que es decomposicion?<br>
					<br>Utilidad que sirve para dividir el códiog en componentes que
					colaboran con un fin en comun, se puede pensar como mini Programas
					dentro de un programa mayor<br>
					<br>¿Como usar funciones?<br>
					<br>estructura de una funcion en python:<br>
					1. palabra reservada "def"<br>
					2. Nombre de la funcion<br>
					3. Parametros<br>
					4. Cuerpo de la funcion<br>
					5. palabra reservada "return" acompañada del valor o solucion que retorna la funcion<br>
					6. Ejemplo:<br>def nombre (parametros):<br>
					cuerpo de la funcion<br>
					return solucion<br>
				</p>
				<footer>
					Pie de la seccion de Funciones y abstraccion
				</footer>
			</article>
	    </section>
		<section>
			<article>
				<header>	
					<h2>Scope o alcance</h2>
				</header>
				<p>
					Cual es el alcance de las funciones, este analisis se realiza
					por medio de frames, dividiendo el codigo desde la funcion mas interna
					<br>Scope global: Variable en el cuerpo principal del codigo, se puede
					usar en cualquier parte.<br>
					<br>Scope local: Variable en una funcion pertenece a esa funcion y 
					las funciones internas.
					<br><br>Keyword global: Se puede crear una variable golbal dentro de una
					funcion usando la keyword "global", se puede modificar el valor de esta
					variable haciendo uso de la misma keyword.
				</p>
				<footer>
					Pie de articulo de Scope, realizar ejemplo ilustrativo
				</footer>
			</article>
	    </section>
		<section>
			<article>
				<header>	
					<h2>Especificaciones del codigo</h2>
				</header>
				<p>
					Comentarios que describan la funcionalidad de las funciones, esto se hace
					con la triple-doble comilla. Se debe colocar el texto inmediatamente despues
					de citar la funcion.<br><br>
					Para consultar que hace una funcion, se llama la funcion help(nombre_funcion)
					. Eso retorna el parrafo de texto que se cito.
				</p>
				<footer>
					Leer acerca de documentacion de funciones en los diferentes lenguajes de programacion
				</footer>
			</article>
	    </section>
		<section>
			<article>
				<header>
					<h2>Recursividad</h2>
				</header>
				<p>
					<br>Recursividad algoritmica:<br>					
					<br>Principio de "Divide y venceras" al separar un problema en
					varios pequeños problemas<br>
					<br>Recursividad programatica:<br>
					<br>Tecnica programatica mediante la cual una funcion se llama
					asi misma<br>
					<br>Formula de los factoriales<br>
					<br><br>
					<br><br>
				</p>
				<footer>
					Investigar limite de recursividad en lenguajes de programacion
				</footer>
			</article>
	    </section>
		<section>
			<article>
				<header>	
					<h2>Fibonnacci y la recursividad</h2>
				</header>
				<p>
					Texto dentro del curso.
					Super genial!!! Implementar codigo para memorizar y evitar 
					gastar recursos de maquina en procesos de ejecucion
				</p>
				<footer>
					Recordar realizar el respectivo aporte en el capitulo de 
					Fibonnacci
					Triangulo de Pascal
					Polinomios de Hermite
				</footer>
			</article>
	    </section>
	</div>
	<div>
		<section>
			<article>
				<header><h2>Funciones como objetos</h2></header>
				<p>
					En python tooodo es un objeto, por ende, las funciones tienen:<br>
					1. Un tipo<br>
					2. Se pueden pasar como argumentos de otras funciones<br>
					3. Se pueden utilizar en expresiones con lambda<br>
					4. Se pueden incluir en varias estructuras de datos (En listas, tuplas, diccionarios, etc)<br>
				</p>
				<footer>Pie de funciones como objetos</footer>
			</article>
		</section>
		<section>
			<article>
				<header><h2>Tuplas</h2></header>
				<p>
					Se simbolizan con "()" parentesis redondos<br>
					Es un tipo estructurado<br>
					Son secuencias inmutables de objetos<br>
					Puede contener cualquier tipo de objeto<br>
					Se usa para devolver varios valores en una funcion<br>
					No se puede agregar o cambiar un valor en la tupla ya que son inmutables<br>
					Se pueden desempaquetar al igualarla con las respectivas variables,
					ejemplo: x, y, z = my_tuple<br>
					teniendo en cuenta que my_tuple=(1,3,5)<br>
				</p>
				<footer>Investigar uso practico y puntual de las tuplas</footer>
			</article>
		</section>
		<section>
			<article>
				<header><h2>Rangos</h2></header>
				<p>
					Representan una secuencia de enteros<br>
					range(comienzo,fin,pasos)<br>
					Los rangos son inmutables<br>
					los rangos son "NO INCLUSIVOS"<br>
					Eficientes en uso de memoria y utilizados en los ciclos FOR<br>
				</p>
				<footer>Pie de rangos, reto con todos los numeros NONES o IMPARES </footer>
			</article>
		</section>
		<section>
			<article>
				<header><h2>Listas y mutabilidad</h2></header>
				<p>
					Secuencias de objetos<br>
					SII son mutables<br>
					Cuando se modifica una lista pueden ocurrir problemas (side effects)<br>
					Es posible iterar con las listas<br>
					Para modificar se puede via indice, ejemplo: myList[0]=10<br>
					Metodos de lista: append, pop, remove, insert, etc<br>
					Existen efectos secundarios cuando una asignacion de lista apunta
					a un mismo lugar de memoria. Para solucionar este inconveniente se usa
					la clonacion. <br>
					Para clonar una lista se usan slices "[::]" o la funcion list(my_list)<br>
					<br><br>
					list comprehension: Forma de aplicar operaciones a los valores de una secuencia<br>
					Tambien se pueden aplicar condiciones para filtrar.<br><br>
					ejemplo:<br>my_list=list(range(100))<br>
					#Para multiplicar todos los valores de la lista por dos<br>
					double=[i*2 for i in my_list]<br>
					#para imprimir todos los pares<br>
					pares=[i for i in my_list if i % 2 == 0]<br>
				</p>
				<footer>Pie de listas, reto de todos los metodos de listas en Python</footer>
			</article>
		</section>
		<section>
			<article>
				<header><h2>Diccionarios</h2></header>
				<p>
					Son como listas, pero en lugar de indices usan llaves<br>
					No tienen orden interno <br>
					Son mutables<br>
					Pueden iterarse<br>
					palabra reservada "del" para eliminar un key<br>
					palabra True u False para verificar si hay una Key o un valor en el diccionario
					Limpiar o borrar todo lo que hay en el diccionario, my_dicti.clear()<br>
					Dictionary comprehension: Se maneja la misma logica que con las listas.<br>
					Revisar este material: https://www.datacamp.com/community/tutorials/python-dictionary-comprehension<br>
					Funcion map(), muy util a la hora de pasar argumentos a una funcion para 
					ahorrar codigo, se usa junto con las funciones lambda.
					Funcion filter(), <br>
					Funcion reduce(), <br>
					Nested Dictionary comprehension is a beutifull concept
				</p>
				<footer>El reto para este video es validar de que forma se pueden elaborar

				</footer>
			</article>
		</section>
	</div>
	<div>
		<section>
			<article>
				<header><h2>Prueba de caja negra</h2></header>
				<p>
					Prueba que se realiza para tratamiento de problemas en el codigo
					o tramtamiento de Buggs<br>
					Estas pruebas se basan en la especificacion de la funcion
					o el programa<br>
					Prueba de inputs y valida outputs<br>
					Unit testing o integration testing<br>
					<br><br>SE debe importar la libreria unittest<br>
					SE crea una clase que revisa los diferentes resultados de una funcion
				</p>
				<footer>Pie de prueba de caja negra</footer>
			</article>
		</section>
		<section>
			<article>
				<header><h2>Prueba de caja de cristal</h2></header>
				<p>
					<br>SE basan en el flujo del programa<br>
					<br>Prueba todos los caminos posibles de una funcion.
					Ramificaciones, bucles for y while, recursion<br>
					<br>Regression testing o mocks<br>
					7 Principios de las Pruebas de software:<br>
					1. Las pruebas demuestran la presencia de defectos,
					no su ausencia<br>
					2. Las pruebas exhaustivas no existen o son imposibles<br>
					3. Las pruebas tempranas ahorran tiempo y dinero<br>
					4. Agrupacion de defectos, regla 80-20<br>
					5. Tener cuidado con la paradoja del pesticida, no usar la 
					misma prueba despues de un tiempo<br>
					6. Las pruebas dependen del contexto<br>
					7. Falacia de ausencia de errores<br>
					<br>
				</p>
				<footer>Pie de caja de cristal</footer>
			</article>
		</section>
		<section>
			<article>
				<header><h2>Debugging</h2></header>
				<p>
					Debbuging<br>
					Leer acerca del tratamiento de Buggs<br>
					Reglas generales:<br>
					1. Usar el print statement<br>
					2. Estudia los datos disponibles<br>
					3. Utiliza los datos para crear hipotesis y experimentos<br>
					4. Ten una mente abierta, si entendieras el programa probablemente
					no habrìan Buggs<br>
					5. Lleva un registro de lo que has tratado, preferentemente
					en la forma de test.<br>
				</p>
				<footer>Pie de Debugging</footer>
			</article>
		</section>
	</div>
	<div>
		<section>
			<article>
				<header><h2>Manejo de excepciones</h2></header>
				<p>
					1. Son muy comunes en la programacion.
					no tienen nada de excepcional.<br>
					2. Las excepciones de Python normalmente se
					relacionan con errores de semantica<br>
					3. Se pueden crear excepciones propias<br>
					4. Cuando una excepcion no se maneja,
					el programa termina en error<br>
					5. Las excepciones se manejan con los keywords: try, except, finally<br>
					6. Se pueden utilizar tambien para ramificar Programas<br>
					7. No deben manejarse de manera silenciosa<br>
					8. Para aventar tu propia excepcion utiliza el keyword "raise"<br>
				</p>
				<footer>Pie de manejo de excepciones</footer>
			</article>
		</section>
		<section>
			<article>
				<header><h2>Excepciones y control de flujo</h2></header>
				<p>
					1. El manejo de excepciones tambien sirve para control de flujo,
					como lo realizan los condicionales if,else<br>
					2. Principio de EAFP(Easier to ask for forgiveness than permission) para Python<br>
					2.1 En otros lenguajes de programacion es LBYL(Look before you leap)<br>
					
				</p>
				<footer>LEER MAS ACERCA DE EXCEPCIONES Y CONTROL DE FLUJO</footer>
			</article>
		</section>
		<section>
			<article>
				<header><h2>Afirmaciones</h2></header>
				<p>
					1. Mecanismo que determina si una condicion se cumple o no,
					es un metodo de programacion defensiva.<br>
					2. Pueden utilizarse para verificar que los tipos sean
					correctos en una funcion.<br>
					3. Sirven para debuguear<br>
					4. SE usa el keyword "assert"<br>
					5. Ejemplo: assert type(palabra)==str, '{palabra} NO ES UN str'<br>
				</p>
				<footer>Pie de afirmaciones</footer>
			</article>
		</section>
	</div>
    </body>
    <footer>
		TODO ESTO VA LIGADO CON INGENIERIA DE SOFTWARE<br>
		ESTE ES EL PIE DE TOOODO EL DOCUMENTO: informacion de la pagina y de contacto<br>
    </footer>
</html>
